import os
import re
import time
from decimal import Decimal, ROUND_UP
from dotenv import load_dotenv
from flask import Flask, request, jsonify, render_template, redirect, url_for, flash, session
from flask_login import LoginManager, login_user, logout_user, login_required, current_user
from authlib.integrations.flask_client import OAuth

# --- AI IMPORTS (GROQ ONLY) ---
from langchain_groq import ChatGroq
from duckduckgo_search import DDGS 
from langchain_core.tools import tool
from langchain_core.messages import HumanMessage, SystemMessage, ToolMessage, AIMessage, BaseMessage
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.sqlite import SqliteSaver
from langgraph.checkpoint.postgres import PostgresSaver
from psycopg_pool import ConnectionPool
from typing import TypedDict, Annotated, List
import operator

# --- DATABASE MODELS ---
from models import db, User

# --- SETUP ---
load_dotenv()
app = Flask(__name__, template_folder='templates')

# --- CONFIG ---
app.config['SECRET_KEY'] = os.environ.get('FLASK_SECRET_KEY')
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL')
app.config['YOUR_DOMAIN'] = os.environ.get('YOUR_DOMAIN')
app.config['SESSION_COOKIE_SECURE'] = False
app.config['SESSION_COOKIE_HTTPONLY'] = True
app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'

# --- DATABASE STABILITY (USER DB) ---
# Keep this conservative
app.config['SQLALCHEMY_ENGINE_OPTIONS'] = {
    "pool_pre_ping": True,
    "pool_recycle": 300,
    "pool_size": 1,
    "max_overflow": 0,
    "pool_timeout": 10
}

# Auth0
app.config['AUTH0_CLIENT_ID'] = os.environ.get('AUTH0_CLIENT_ID')
app.config['AUTH0_CLIENT_SECRET'] = os.environ.get('AUTH0_CLIENT_SECRET')
app.config['AUTH0_DOMAIN'] = os.environ.get('AUTH0_DOMAIN')

db.init_app(app)

# --- LOGIN MANAGER ---
login_manager = LoginManager()
login_manager.login_view = 'login'
login_manager.init_app(app)

@login_manager.user_loader
def load_user(user_id):
    return db.session.get(User, int(user_id))

# --- OAUTH ---
oauth = OAuth(app)
auth0 = oauth.register(
    'auth0',
    client_id=app.config['AUTH0_CLIENT_ID'],
    client_secret=app.config['AUTH0_CLIENT_SECRET'],
    api_base_url=f"https://{app.config['AUTH0_DOMAIN']}",
    access_token_url=f"https://{app.config['AUTH0_DOMAIN']}/oauth/token",
    authorize_url=f"https://{app.config['AUTH0_DOMAIN']}/authorize",
    client_kwargs={'scope': 'openid profile email'},
    server_metadata_url=f"https://{app.config['AUTH0_DOMAIN']}/.well-known/openid-configuration"
)

# ==============================================================================
# 1. INITIALIZE GROQ
# ==============================================================================

try:
    groq_llm = ChatGroq(
        model_name='llama-3.3-70b-versatile', 
        api_key=os.environ.get('GROQ_API_KEY')
    )
    print("âœ… Groq AI Client Initialized Successfully")
except Exception as e:
    print(f"CRITICAL: AI Client failed to load. {e}")

# ==============================================================================
# 2. DEFINE THE TOOLS
# ==============================================================================

@tool
def ui_builder_tool(prompt: str) -> str:
    """Use this tool to generate HTML, CSS, React, or Frontend code."""
    messages = [
        SystemMessage(content="You are an expert Frontend Developer. Generate clean, modern HTML/Tailwind code. Output ONLY the code."),
        HumanMessage(content=prompt)
    ]
    response = groq_llm.invoke(messages)
    return f"[UI Generated by Groq] \n\n {response.content}"

@tool
def backend_builder_tool(prompt: str) -> str:
    """Use this tool to generate Python, Flask, SQL, or complex Backend logic."""
    messages = [
        SystemMessage(content="You are a Senior Backend Engineer. Write secure, production-ready Python code."),
        HumanMessage(content=prompt)
    ]
    response = groq_llm.invoke(messages)
    return f"[Backend Generated by Groq] \n\n {response.content}"

@tool
def web_search_tool(query: str, **kwargs) -> str:
    """Use this tool to find real-time information, news, weather, or specific facts."""
    print(f"ðŸ”Ž SEARCHING FOR: '{query}'") 
    if not query or len(query.strip()) < 2: return "Error: Empty search query."

    try:
        results = DDGS().text(query, max_results=5, backend="lite")
        if not results: results = DDGS().text(query, max_results=5)
        if not results: return "No search results found."
        
        valid_results = []
        for r in results:
            title = r.get('title', '').lower()
            if "google chrome" in title or "google translate" in title: continue
            valid_results.append(f"Title: {r.get('title')}\nLink: {r.get('href')}\nSnippet: {r.get('body')}\n")

        if not valid_results: return "Search blocked by bot protection."
        return "\n".join(valid_results)
    except Exception as e:
        return f"Search Tool Error: {str(e)}"

# ==============================================================================
# 3. BUILD THE AGENT GRAPH (TEMPLATE)
# ==============================================================================

tools = [ui_builder_tool, backend_builder_tool, web_search_tool]
agent_brain = groq_llm.bind_tools(tools)

class AgentState(TypedDict):
    messages: Annotated[List[BaseMessage], operator.add]

def brain_node(state):
    return {"messages": [agent_brain.invoke(state["messages"])]}

def tool_node(state):
    last_message = state["messages"][-1]
    tool_calls = last_message.tool_calls
    results = []
    final_content = ""
    
    for t in tool_calls:
        selected_tool = {
            "ui_builder_tool": ui_builder_tool,
            "backend_builder_tool": backend_builder_tool,
            "web_search_tool": web_search_tool
        }.get(t["name"])
        
        if selected_tool:
            valid_args = {}
            if "query" in t["args"]: valid_args["query"] = t["args"]["query"]
            elif "prompt" in t["args"]: valid_args["prompt"] = t["args"]["prompt"]
            else: valid_args = t["args"]
            output = selected_tool.invoke(valid_args)
            results.append(ToolMessage(tool_call_id=t['id'], name=t['name'], content=str(output)))
            final_content += str(output) + "\n\n"
            
    results.append(AIMessage(content=final_content))
    return {"messages": results}

def should_continue(state):
    last_message = state["messages"][-1]
    if last_message.tool_calls: return "tools"
    return END

workflow = StateGraph(AgentState)
workflow.add_node("brain", brain_node)
workflow.add_node("tools", tool_node)
workflow.set_entry_point("brain")
workflow.add_conditional_edges("brain", should_continue, {"tools": "tools", END: END})
workflow.add_edge("tools", END)

# ==============================================================================
# 4. DATABASE & APP LOGIC (SAFE CONNECTION HANDLING)
# ==============================================================================

def get_checkpointer():
    """
    Creates a FRESH, temporary connection pool for a single request.
    This prevents connection hoarding.
    """
    db_url = os.environ.get("DATABASE_URL")
    if db_url and db_url.startswith("postgresql"):
        # Create a transient pool (min_size=0, closes immediately)
        pool = ConnectionPool(
            conninfo=db_url, 
            min_size=0, 
            max_size=1, 
            kwargs={"autocommit": True}
        )
        return PostgresSaver(pool), pool
    else:
        # Local fallback
        return SqliteSaver.from_conn_string("checkpoints.sqlite"), None

def init_db():
    """Run once on startup to ensure tables exist"""
    saver, pool = get_checkpointer()
    try:
        with app.app_context():
            db.create_all()
            if hasattr(saver, 'setup'): saver.setup()
    finally:
        if pool: pool.close() # Close immediately

def simple_chat(prompt):
    return groq_llm.invoke([HumanMessage(content=prompt)]).content

@app.route("/api/ask", methods=["POST"])
@login_required
def handle_ask():
    user_prompt = request.json.get("prompt")
    user_id = current_user.auth0_id
    
    # 1. ROUTING
    try:
        classification = groq_llm.invoke([
            SystemMessage(content="Classify as 'simple' (jokes, greetings) or 'complex' (code, news, people). Return ONLY one word."), 
            HumanMessage(content=user_prompt)
        ]).content.strip().lower()
    except:
        classification = 'complex' 

    final_answer = ""
    cost_estimate = 0.0

    # 2. EXECUTION
    if "simple" in classification:
        final_answer = simple_chat(user_prompt)
    else:
        # Use Transient Checkpointer for safety
        saver, pool = get_checkpointer()
        try:
            config = {"configurable": {"thread_id": user_id}, "recursion_limit": 50}
            
            agent_system_message = SystemMessage(content="""
            You are a helpful AI assistant.
            RULES:
            1. If asked about people/news, USE 'web_search_tool'.
            2. Don't guess. Search.
            """)
            
            # Compile graph with this specific saver
            app_workflow = workflow.compile(checkpointer=saver)
            
            result = app_workflow.invoke(
                {"messages": [agent_system_message, HumanMessage(content=user_prompt)]}, 
                config=config
            )
            final_answer = result["messages"][-1].content
        except Exception as e:
            print(f"âš ï¸ Agent Error: {e}")
            final_answer = "I encountered an error connecting to my memory. Please try again."
        finally:
            # CRITICAL: Close the connection pool immediately!
            if pool: pool.close()

    # 3. BILLING
    try:
        current_user.credits -= Decimal(cost_estimate)
        db.session.commit()
    except:
        db.session.rollback()

    return jsonify({
        "answer": final_answer,
        "cost": cost_estimate,
        "remaining": float(current_user.credits) if current_user.credits else 0.0
    })

# --- ROUTES ---
@app.route('/')
def index():
    if current_user.is_authenticated: return redirect(url_for('chat_interface'))
    return render_template('landing.html')

@app.route('/app')
@login_required
def chat_interface():
    return render_template('ai_assistant.html', user_credits=current_user.get_credit_balance())

@app.route('/login')
def login(): return oauth.auth0.authorize_redirect(redirect_uri=url_for('callback', _external=True))

@app.route('/signup')
def signup(): return oauth.auth0.authorize_redirect(redirect_uri=url_for('callback', _external=True), screen_hint='signup')

@app.route('/callback')
def callback():
    try:
        token = oauth.auth0.authorize_access_token()
        user_info = auth0.get('userinfo').json()
        auth0_id = user_info.get('sub')
        email = user_info.get('email')
        
        if not auth0_id or not email:
            flash("Error retrieving user info", "error")
            return redirect(url_for('index'))

        user = User.query.filter_by(auth0_id=auth0_id).first()
        if not user:
            user = User.query.filter_by(email=email).first()
            if user:
                user.auth0_id = auth0_id
                db.session.commit()
            else:
                user = User(auth0_id=auth0_id, email=email, credits=Decimal('50.0'))
                db.session.add(user)
                db.session.commit()
        
        login_user(user, remember=True)
        return redirect(url_for('chat_interface'))
    except Exception as e:
        print(f"Callback Error: {e}")
        db.session.rollback()
        return redirect(url_for('index'))

@app.route('/logout')
def logout():
    session.clear()
    logout_user()
    return redirect(f"https://{app.config['AUTH0_DOMAIN']}/v2/logout?client_id={app.config['AUTH0_CLIENT_ID']}&returnTo={url_for('index', _external=True)}")

@app.route('/pricing')
@login_required
def pricing_page():
    return render_template('pricing.html')

if __name__ == "__main__":
    init_db() # Run table creation once
    app.run(host='0.0.0.0', port=5000, debug=True)